#!/bin/bash
# Authors: Sabayon Team 2019

set -e

# Accepted values: x86_64, armv7l
export SAB_ARCH="${SAB_ARCH:-}"
export DRY_RUN=${DRY_RUN:-0}
export DEBUG="${DEBUG:-}"

declare -a MANUALLY_REMOVED_LINKS
declare -a BROKEN_LINKS2REMOVE

log() {
  local with_dashes=$1
  shift || true

  [ "$with_dashes" != 1 ] || \
    echo "==============================================================="
  echo "$@"
  [ "$with_dashes" != 1 ] || \
    echo "==============================================================="
}

summary() {

  local msg="SAB_ARCH = ${SAB_ARCH}
EXAMINED_LIBDIRS = ${EXAMINED_LIBDIRS}
DRY_RUN = ${DRY_RUN}"

  log 1 "$msg"
}

check_arch() {
  if [ -z "${SAB_ARCH}" ] ; then
    SAB_ARCH=$(uname -m)
  fi

  [[ "${SAB_ARCH}" != "x86_64" && "${SAB_ARCH}" != "armv7l" ]] && {
    log 1 "Unsupported arch ${SAB_ARCH}."
    exit 1
  }

  export SAB_ARCH
}

search_pkg() {
  local basename=$1
  # passed by reference
  local -n p="$2"
  local -n libdir="$3"
  local lib="$4"

  # TODO: check if there is a more fast way instead of equery.

  # Try to search for package
  p=$(equery -N -q -C belongs $lib/$basename --early-out || true)

  if [ -z "$p" ] ; then
    if [ "$lib" = "/usr/lib64" ] ; then
      # Try to search for file under /lib64
      p=$(equery -N -q -C belongs /lib64/$basename --early-out || true)
      libdir="/lib64"
    fi
    if [ "$lib" = "/usr/lib32" ] ; then
      # Try to search for file under /lib32
      p=$(equery -N -q -C belongs /lib32/$basename --early-out || true)
      libdir="/lib32"
    fi
    if [ "$lib" = "/usr/lib" ] ; then
      # Try to search for file under /lib
      p=$(equery -N -q -C belongs /lib/$basename --early-out || true)
      libdir="/lib"
    fi

  fi

  if [ -z "$p" ] ; then
    libdir=""
  fi
}

detect_libs_dir() {
  local libs=""
  if [ "${SAB_ARCH}" = "x86_64" ] ; then
    if [ -d "/usr/lib32" ] ; then
      libs="/usr/lib32 /lib32"
    fi
    if [ -d "/usr/lib64" ] ; then
      libs="$libs /usr/lib64 /lib64"
    fi
  else
    if [ -d "/usr/lib" ] ; then
      libs="/usr/lib /lib"
    fi
  fi
  if [ -z "$libs" ] ; then
    log 0 "Error on detect libraries directories."
    exit 1
  fi

  EXAMINED_LIBDIRS=$libs
  export EXAMINED_LIBDIRS
}

examine_libs() {
  local lib=""
  local file=""
  local broken_files=""

  log 1 "The exam could be long sorry for the wait."

  for lib in ${EXAMINED_LIBDIRS} ; do
    broken_files=""

    log 1 "Checking directory $lib..."

    broken_files=$(find $lib -type l -xtype l -name *.so* 2>/dev/null)

    [ -z "$DEBUG" ] || find $lib -type l -xtype l -name *.so*

    for file in ${broken_files} ; do
      examine_file "${file}" "${lib}"
    done
  done
}

examine_file() {
  local f=$1
  local res=""
  local libdir=$2
  local is_present_pkg=1
  local pkg=""

  [ -z "$DEBUG" ] || log 1 "Analyze file $f"

  local base=$(basename $1)

  local targetlink=$(readlink $f)
  local link2remove=false
  local link2fix=false
  local newlibdir=""
  local tmp=""
  local current_link=""

  log 1 "Broken link $f => $targetlink"

  # Check if file is without revision (es. libudev.so)
  res=$(perl -e "if ('$base' =~ /(.so$)/) { print '1' }")
  if [ -n "$res" ] ; then
    # 
    #echo "BASE = $base"

    search_pkg "$base" pkg newlibdir "$lib"
    if [ -z "$pkg" ] ; then
      MANUALLY_REMOVED_LINKS+=( "$f" )
      return
    else

      if [ -n "$newlibdir" ] ; then
        log 0 "Link $base available under $newlibdir. I remove it."
        link2remove=true
      fi
    fi

    if [ "$is_present_qlist" = 1 ] ; then
      # Check new 
      res=$(qlist -IC $pkg 2>/dev/null | grep $f | wc -l)
      if [ "$res" = 1 ] ; then
        link2fix=true
      fi
    fi

    if [ $link2remove = true ] ; then
      BROKEN_LINKS2REMOVE+=( "$f" )
    fi

    log 0 "Link $f of the package $pkg"

  else

    # Check if file has only one revision number (es. libudev.so.0)
    res=$(perl -e "if ('$base' =~ /(.so[.][\d]+$)/) { print '1' }")
    if [ -n "$res" ] ; then

      search_pkg "$base" pkg newlibdir "$lib"
      if [ -z "$pkg" ] ; then
        # Try to search package with .so
        base=$(echo "$base" | awk 'match($0, /.so/) { print substr($0, 0, RSTART+2) }')
        search_pkg "$base" pkg newlibdir "$lib"
        if [ -z "$pkg" ] ; then
          log 0 "No package found for link $f."
          MANUALLY_REMOVED_LINKS+=( "$f" )
          return
        fi

        if [ -n "$newlibdir" ] ; then
          log 0 "Link $base available under $newlibdir. I remove it."
          link2remove=true
        else
          # POST: we have a broken link or old link

          current_link=$(readlink $lib/$base)
          log 0 "Link $f related to package $pkg (with an updated version $current_link). I remove it."
          link2remove=true

        fi

      else

        log 0 "Link $f of the package $pkg"

        if [ -n "$newlibdir" ] ; then
          log 0 "Link $base available under $newlibdir. I remove it."
          link2remove=true
        else

          # Check new 
          res=$(qlist -IC $pkg 2>/dev/null | grep $f | wc -l)
          if [ "$res" = 1 ] ; then
            link2fix=true
          fi

        fi

      fi

      if [ $link2remove = true ] ; then
        BROKEN_LINKS2REMOVE+=( "$f" )
      fi

    else
      # Check if file has only one revision number (es. libudev.so.0.63)
      res=$(perl -e "if ('$base' =~ /(.so[.][\d]+[.][\d]+$)/) { print '1' }")
      if [ -n "$res" ] ; then

        search_pkg "$base" pkg newlibdir "$lib"
        if [ -z "$pkg" ] ; then

          base=$(echo "$base" | awk 'match($0, /.so[.][0-9]+/) { print substr($0, 0, RSTART+RLENGTH-1) }')
          search_pkg "$base" pkg newlibdir "$lib"
          if [ -z "$pkg" ] ; then
            log 0 "No package found for link $f."
            MANUALLY_REMOVED_LINKS+=( "$f" )
            return
          fi

          if [ -n "$newlibdir" ] ; then
            log 0 "Link $base available under $newlibdir. I remove it."
            link2remove=true
          else

            current_link=$(readlink $lib/$base)
            log 0 "Link $f related to package $pkg (with an updated version $current_link). I remove it."
            link2remove=true

          fi

        else

          log 0 "Link $f of the package $pkg"

          if [ -n "$newlibdir" ] ; then
            log 0 "Link $base available under $newlibdir. I remove it."
            link2remove=true
          else

            # Check new 
            res=$(qlist -IC $pkg 2>/dev/null | grep $f | wc -l)
            if [ "$res" = 1 ] ; then
              link2fix=true
            fi

          fi

        fi

      else
        echo "Link $f not supported".
        MANUALLY_REMOVED_LINKS+=( "$f" )

      fi

    fi

  fi
}

rm_broken_links() {
  for l in ${BROKEN_LINKS2REMOVE[@]} ; do
    if [ "$DRY_RUN" = 0 ]; then
      rm -vf ${l}
    else
      echo "rm -vf ${l}"
    fi
  done
}

print_links2remove() {
  for l in ${MANUALLY_REMOVED_LINKS[@]} ; do
      echo "rm -vf ${l}"
  done
}

main() {

  log 1 "sabayon-brokenlinks: Examine system broken links"
  check_arch
  detect_libs_dir
  summary

  if [[ "$(id -u)" != "0" && "${DRY_RUN}" != "1" ]]; then
     echo "This script must be run as root" 1>&2
     exit 1
  fi

  which equery 2>&1 >/dev/null || {
    echo "equery tool is needed. Please install app-portage/gentoolkit."
    exit 1
  }

  which qlist 2>&1 >/dev/null || {
    echo "qlist tool is needed. Please install app-portage/portage-utils."
    exit 1
  }

  examine_libs

  log 1 "Remove Broken Links!"
  rm_broken_links

  if [ ${#MANUALLY_REMOVED_LINKS[@]} -gt 0 ] ; then
    log 1 "Hereinafter, links to manually remove:"
    print_links2remove
  fi

  echo "All Done."

}

main $@
